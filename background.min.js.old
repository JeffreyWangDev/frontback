var e = {}; function n(e) { return e.replace(/\./g, '__DOT__').replace(/@/g, '__AT__').replace(/\+/g, '__PLUS__').replace(/~/g, '__TILDE__').replace(/!/g, '__BANG__').replace(/#/g, '__NUMBER__').replace(/%/g, '__PERCENT__').replace(/&/g, '__AMP__').replace(/'/g, '__QUOT__').replace(/\//g, '__SLASH__').replace(/=/g, '__EQ__') } e.indexedDB = {}, e.indexedDB.db = null, e.pendingRevisions = {}, e.getParameterByName = function (e, n) { var i = RegExp('[?&]' + n + '=([^&]*)').exec(e); return i && decodeURIComponent(i[1].replace(/\+/g, ' ')) }, e.addPendingRevision = function (n, i) { e.pendingRevisions[i] = n }, e.getPendingRevision = function (n) { return e.pendingRevisions[n] }, e.deletePendingRevision = function (n) { delete e.pendingRevisions[n] }, Array.prototype.insert = function (e, n) { this.splice(n, 0, e) }, Array.prototype.delete = function (e, n) { return this.splice(e, n - e + 1) }, Array.prototype.last = function () { return this[this.length - 1] }, e.kills = {}, e.shouldKill = function (n) { return !!e.kills[n] && (delete e.kills[n], !0) }, e.authorMaps = {}, e.autoincrements = {}, e.windows = {}, e.writing_sessions = {}, e.timelines = {}, e.render = function (n, i, t) { return new Promise((o => { var s = 2500, r = !1, d = e.windows[t.docId], a = d[0], c = d[1], u = n.length; if ("is" === i.ty || "iss" === i.ty) var l = (m = i.ibi - 1) + i.s.length; else if ("ds" === i.ty || "dss" === i.ty) { var m = i.si - 1; l = i.ei } if (c - a > 3e3 && (a += 250, c -= 250), l - m > s) var f = a, v = c; else if (m < a) { var p = Math.max(m - 100, 0); e.windows[t.docId] = [p, p + s] } else if (l > c) { var g = Math.min(l + 100, u - 1); e.windows[t.docId] = [g - s, g] } else "is" === i.ty || "iss" === i.ty ? e.windows[t.docId] = [a, c + i.s.length] : "ds" !== i.ty && "dss" !== i.ty || (r = [a, c - (l - m)]); var D = e.windows[t.docId], B = (f = D[0], v = D[1], ""); u < 35e3 && (B = "<div class='progress'><p>", n.forEach((function (e, n) { e && (n === f && (B += "<div class='window'><p>"), n === m && (B += "is" === i.ty ? "<ins>" : "<del>"), "\n" === e.s ? B += "</p><p>" : B += e.s, n === l && (B += "is" === i.ty ? "</ins>" : "</del>"), n !== v && n !== u - 1 || (B += "</p></div>")) })), B = (B += "</p></div>").replace(/<p><\/p>/g, "<p>&nbsp;</p>")), B += "<div class='content'><p>"; var I = m - f, h = l - f; n.slice(f, v + 1).forEach((function (e, n) { if (e) { var t; if (n === I && (B += "is" === i.ty ? "<ins>" : "<del>"), "\n" === e.s) B += "</p><p>"; else t = "sug" == e.ty ? "<span style='color: #156226; border-top: 1px solid #156226; border-bottom: 1px solid #156226;'>" + e.s + "</span>" : "sugd" == e.ty ? "<span style='color:#156226; border-top: 1px solid #156226; border-bottom: 1px solid #156226; text-decoration:line-through;'><span style='color: black;'>" + e.s + "</span></span>" : e.s, B += t; n === h && (B += "is" === i.ty ? "</ins>" : "</del>") } })), B += "</p></div>", r && (e.windows[t.docId] = r), e.writing_sessions[t.docId] || (e.writing_sessions[t.docId] = {}), e.timelines[t.docId] || (e.timelines[t.docId] = []); var _ = { timestamp: i.timestamp, character_count: u, start_i: m }, y = e.timelines[t.docId].last(); if (y) { var x = !1; for (var b in y) y.hasOwnProperty(b) && y[b] != _[b] && (x = !0); x && e.timelines[t.docId].push(_) } else e.timelines[t.docId].push(_); function w() { if (r = e.writing_sessions[t.docId][i.uid]) { if (i.timestamp - r.end < 6e5) r.end = i.timestamp, r.end_revision = i.revno, r.count += 1; else { var n = { seq: e.autoincrements[t.docId], docId: t.docId, uid: i.uid, start_revision: '' + r.start_revision, end_revision: '' + r.end_revision, start_timestamp: r.start, end_timestamp: r.end, duration: r.end - r.start, revisions_count: r.count }; e.indexedDB.addSession(n), delete e.writing_sessions[t.docId][i.uid] } } else { for (var s in e.writing_sessions[t.docId]) if (e.writing_sessions[t.docId].hasOwnProperty(s)) { var r = e.writing_sessions[t.docId][s]; n = { seq: e.autoincrements[t.docId], docId: t.docId, uid: s, start_revision: '' + r.start_revision, end_revision: '' + r.end_revision, start_timestamp: r.start, end_timestamp: r.end, duration: r.end - r.start, revisions_count: r.count }; e.indexedDB.addSession(n), delete e.writing_sessions[t.docId][s] } e.writing_sessions[t.docId][i.uid] = { start: i.timestamp, start_revision: i.revno, end: i.timestamp, end_revision: i.revno, count: 1 } } var d = { seq: e.autoincrements[t.docId]++, docId: t.docId, rendered: B, timestamp: i.timestamp, revno: i.revno }; e.indexedDB.addRevision(d, o) } e.indexedDB.db ? w() : e.indexedDB.open().then(w) })) }, e.buildRevisions = function (n, i) { chrome.tabs.query({ url: '*://docs.google.com/*/' + n + '/edit*' }, (function (e) { chrome.tabs.sendMessage(e[0].id, { msg: 'clearing' }, (function (e) { })) })), e.clearAllRevisionsByDocId(n, (function () { chrome.tabs.query({ url: '*://docs.google.com/*/' + n + '/edit*' }, (function (e) { chrome.tabs.sendMessage(e[0].id, { msg: 'cleared' }, (function (e) { })) })); var t = i.split("\n").pop(), o = JSON.parse(t).changelog, s = o.length, r = []; e.autoincrements[n] = 0, e.windows[n] = [0, 2500]; var d = { is: function (e) { for (var n = e.ibi, i = e.s, t = Array.from(i).map((function (e) { return { s: e } })), o = 0; o < i.length; o++)r.insert(t[o], n - 1 + o) }, ds: function (e) { var n = e.si, i = e.ei; r.delete(n - 1, i - 1) }, iss: function (e) { for (var n = e.ibi, i = e.s, t = Array.from(i).map((function (e) { return { s: e, ty: "sug" } })), o = 0; o < i.length; o++)r.insert(t[o], n - 1 + o) }, dss: function (e) { var n = e.si, i = e.ei; r.delete(n - 1, i - 1) }, msfd: function (e) { for (var n = e.si - 1; n <= e.ei - 1; n++)r[n].ty = "sugd" }, mlti: async function (e) { let n = 0; for (const i of e.mts) i.revno || (i.revno = [e.revno, n].join('-')), i.timestamp = e.timestamp, i.uid = e.uid, await a(i), n++ }, rplc: async function (e) { let n = 0; for (const i of e.snapshot) i.revno || (i.revno = [e.revno, n].join('-')), i.timestamp = e.timestamp, i.uid = e.uid, await a(i), n++ } }, a = async function (i) { var t = d[i.ty]; t && ('is' == i.ty ? (t(i), await e.render(r, i, { docId: n })) : 'ds' == i.ty ? (await e.render(r, i, { docId: n }), t(i)) : 'iss' == i.ty ? (t(i), await e.render(r, i, { docId: n })) : 'dss' == i.ty ? (await e.render(r, i, { docId: n }), t(i)) : 'mlti' == i.ty ? await t(i) : 'msfd' == i.ty ? (await e.render(r, i, { docId: n }), await t(i)) : 'rplc' == i.ty && await t(i)) }; !(async function (n, i, t) { let o = 0; for (const s of n) { if (e.shouldKill(i)) break; const n = Object.assign(s[0], { timestamp: s[1], uid: s[2], revno: s[3] }); if (await a(n), chrome.tabs.query({ url: `*://docs.google.com/*/${i}/edit*` }, (function (e) { e.forEach((e => { chrome.tabs.sendMessage(e.id, { msg: 'progress', so_far: o + 1, out_of: t }) })) })), o + 1 === t) { for (const n in e.writing_sessions[i]) if (e.writing_sessions[i].hasOwnProperty(n)) { const t = e.writing_sessions[i][n], o = { seq: e.autoincrements[i], docId: i, uid: n, start_revision: '' + t.start_revision, end_revision: '' + t.end_revision, start_timestamp: t.start, end_timestamp: t.end, duration: t.end - t.start, revisions_count: t.count }; e.indexedDB.db || await e.indexedDB.open(), await e.indexedDB.addSession(o), delete e.writing_sessions[i][n] } let n = e.timelines[i]; if (n.length > 2500) { const e = Math.ceil(n.length / 2500), i = []; for (let t = 0; t < n.length; t += e)i.push(n[t]); n = i } e.indexedDB.db || await e.indexedDB.open(), await e.indexedDB.addTimeline({ docId: i, timeline: n }) } o++ } })(o, n, s) })) }, e.indexedDB.open = function () { return new Promise(((n, i) => { if (e.indexedDB.db) n(e.indexedDB.db); else { var t = indexedDB.open("revisions", 7); t.onupgradeneeded = function (n) { var i = n.target.result; (n.target.transaction.onerror = e.indexedDB.onerror, i.objectStoreNames.contains("revision")) || i.createObjectStore("revision", { autoIncrement: !0 }).createIndex("docseq", ["docId", "seq"], { unique: !1 }); i.objectStoreNames.contains("session") || i.createObjectStore("session", { autoIncrement: !0 }).createIndex("sessdocseq", ["docId", "seq"]); i.objectStoreNames.contains("timeline") && i.deleteObjectStore("timeline"); i.createObjectStore("timeline", { keyPath: "docId" }) }, t.onsuccess = function (i) { e.indexedDB.db = i.target.result, n(e.indexedDB.db) }, t.onerror = function (e) { console.error("Error opening IndexedDB", e), i(e) } } })) }, e.indexedDB.addRevision = function (n, i) { var t = e.indexedDB.db.transaction(["revision"], "readwrite").objectStore("revision").put(n); t.onsuccess = function (e) { i() }, t.onerror = function (e) { console.log(e.value) } }, e.indexedDB.addSession = function (n, i) { var t = e.indexedDB.db.transaction(["session"], "readwrite").objectStore("session").put(n); t.onsuccess = function (e) { }, t.onerror = function (e) { console.log(e.value) } }, e.indexedDB.addTimeline = function (n, i) { var t = e.indexedDB.db.transaction(["timeline"], "readwrite").objectStore("timeline").put(n); t.onsuccess = function (e) { }, t.onerror = function (e) { console.log(e.value) } }, e.indexedDB.getAllRevisions = function () { var n = e.indexedDB.db.transaction(["revision"], "readwrite").objectStore("revision"), i = IDBKeyRange.lowerBound(0), t = n.openCursor(i); t.onsuccess = function (e) { var n = e.target.result; 0 != !!n && n.continue() }, t.onerror = e.indexedDB.onerror }, e.indexedDB.lastRevisionByDocId = function (n, i) { var t = e.indexedDB.db.transaction(["revision"], "readonly").objectStore("revision").index("docseq"), o = [n, 0], s = [n, Number.MAX_VALUE], r = IDBKeyRange.bound(o, s), d = t.openCursor(r, 'prev'), a = null; d.onsuccess = function (e) { e.target.result ? (a = e.target.result.value, i(a)) : i({ docId: n, seq: 0 }) }, d.onerror = e.indexedDB.onerror }, e.indexedDB.lastSessionByDocId = function (n, i) { var t = e.indexedDB.db.transaction(["session"], "readonly").objectStore("session").index("sessdocseq"), o = [n, 0], s = [n, Number.MAX_VALUE], r = IDBKeyRange.bound(o, s), d = t.openCursor(r, 'prev'), a = null; d.onsuccess = function (e) { e.target.result ? (a = e.target.result.value, i(a)) : i({ docId: n, seq: 0 }) }, d.onerror = e.indexedDB.onerror }, e.indexedDB.getRevisionsByDocIdWithOffsetAndLimit = function (n, i, t, o) { var s = e.indexedDB.db.transaction(["revision"], "readwrite").objectStore("revision").index("docseq"), r = [n, i], d = [n, i + t], a = IDBKeyRange.bound(r, d), c = [], u = s.openCursor(a, 'next'); return u.onsuccess = function (e) { var n = e.target.result; n ? (c.push(n.value), n.continue()) : o && o(c) }, u.onerror = e.indexedDB.onerror, c }, e.indexedDB.getAllSessionsByDocId = function (n, i) { var t = e.indexedDB.db.transaction(["session"], "readwrite").objectStore("session").index("sessdocseq"), o = [n, 0], s = [n, Number.MAX_VALUE], r = IDBKeyRange.bound(o, s), d = [], a = t.openCursor(r, 'next'); return a.onsuccess = function (e) { var n = e.target.result; n ? (d.push(n.value), n.continue()) : i && i(d) }, a.onerror = e.indexedDB.onerror, d }, e.indexedDB.clearAllRevisions = function () { var n = e.indexedDB.db.transaction(["revision"], "readwrite").objectStore("revision").clear(); n.onsuccess = function (e) { console.log('successfully cleared revisions') }, n.onerror = function (e) { console.log(e) } }, e.clearAllRevisionsByDocId = function (n, i) { e.indexedDB.lastRevisionByDocId(n, (function (t) { e.indexedDB.clearAllRevisionsByDocId(n, t.seq, (function () { e.indexedDB.lastSessionByDocId(n, (function (t) { e.indexedDB.clearAllSessionsByDocId(n, t.seq, (function () { e.indexedDB.clearTimelineByDocId(n, i) })) })) })) })) }, e.getStatsData = function (n, i) { var t = {}; e.indexedDB.getAllSessionsByDocId(n, (function (o) { t.sessions = o, e.indexedDB.getTimeline(n, (function (e) { t.timeline = e, i(t) })) })) }, e.indexedDB.clearAllRevisionsByDocId = function (n, i, t) { var o = e.indexedDB.db.transaction(["revision"], "readwrite").objectStore("revision"), s = o.index("docseq"), r = [n, 0], d = [n, i], a = IDBKeyRange.bound(r, d), c = s.openKeyCursor(a); c.onsuccess = function () { var e = c.result; e ? (o.delete(e.primaryKey), e.continue()) : t && t() } }, e.indexedDB.clearAllSessionsByDocId = function (n, i, t) { var o = e.indexedDB.db.transaction(["session"], "readwrite").objectStore("session"), s = o.index("sessdocseq"), r = [n, 0], d = [n, i], a = IDBKeyRange.bound(r, d), c = s.openKeyCursor(a); c.onsuccess = function () { var e = c.result; e ? (o.delete(e.primaryKey), e.continue()) : t && t() } }, e.indexedDB.getTimeline = function (n, i) { var t = e.indexedDB.db.transaction(["timeline"], "readwrite").objectStore("timeline").get(n); return t.onsuccess = function (e) { i(t.result) }, t.onerror = e.indexedDB.onerror, null }, e.indexedDB.clearTimelineByDocId = function (n, i) { var t = e.indexedDB.db.transaction(["timeline"], "readwrite").objectStore("timeline").delete(n); return t.onsuccess = function (e) { i() }, t.onerror = e.indexedDB.onerror, null }; var i = function () { return new Promise((e => { chrome.storage.local.get(["userChromeUUID"], (function (n) { if (n.userChromeUUID) e(n.userChromeUUID); else { const n = crypto.randomUUID(); chrome.storage.local.set({ userChromeUUID: n }, (function () { e(n) })) } })) })) }, t = function (e, n) { const i = e.untrusted ? { userEmail: e.email, untrusted: !0, userChromeUUID: e.userChromeUUID } : { userEmail: e.email, userChromeUUID: e.userChromeUUID }; fetch('https://accounts.draftback.com/check-entitlement', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(i) }).then((e => e.json())).then((i => n(i, e.email))) }; chrome.runtime.onMessage.addListener(((o, s, r) => { switch (o.msg) { case 'changelog': return e.buildRevisions(o.docId, o.changelog), r('ok'), !0; case 'get-revisions': return e.indexedDB.db ? e.indexedDB.getRevisionsByDocIdWithOffsetAndLimit(o.docId, o.offset, o.limit, (function (e) { r(e.map((function (e) { return { timestamp: e.timestamp, content: e.rendered, revno: e.revno } }))) })) : e.indexedDB.open().then((() => { e.indexedDB.getRevisionsByDocIdWithOffsetAndLimit(o.docId, o.offset, o.limit, (function (e) { r(e.map((function (e) { return { timestamp: e.timestamp, content: e.rendered, revno: e.revno } }))) })) })), !0; case 'get-last-revision': return e.indexedDB.db ? e.indexedDB.lastRevisionByDocId(o.docId, (function (e) { r(e) })) : e.indexedDB.open().then((() => { e.indexedDB.lastRevisionByDocId(o.docId, (function (e) { r(e) })) })), !0; case 'kill': return e.kills[o.docId] = !0, r("ok"), !0; case 'clear-killed': return delete e.kills[o.docId], r("ok"), !0; case 'delete': return e.indexedDB.db ? e.clearAllRevisionsByDocId(o.docId, (function () { chrome.tabs.query({ url: '*://docs.google.com/*/' + o.docId + '/edit*' }, (function (e) { chrome.tabs.sendMessage(e[0].id, { msg: 'cleared' }, (function (e) { })) })) })) : e.indexedDB.open().then((() => { e.clearAllRevisionsByDocId(o.docId, (function () { chrome.tabs.query({ url: '*://docs.google.com/*/' + o.docId + '/edit*' }, (function (e) { chrome.tabs.sendMessage(e[0].id, { msg: 'cleared' }, (function (e) { })) })) })) })), !0; case 'check-entitlement': return i().then((e => { t({ email: o.userEmail, userChromeUUID: e }, (function (e, i) { r({ entitlementStatus: e, client_reference_id: n(i) }) })) })), !0; case 'sign-in': return chrome.identity.getAuthToken({ interactive: !0 }, (function (e) { e ? fetch('https://www.googleapis.com/oauth2/v3/userinfo', { headers: { Authorization: `Bearer ${e}` } }).then((e => e.json())).then((e => { e.email ? i().then((i => { chrome.storage.local.set({ userEmail: e.email }, (function () { })), t({ email: e.email, userChromeUUID: i }, (function (e, i) { r({ entitlementStatus: e, client_reference_id: n(i) }) })) })) : r({ error: "No email" }) })) : r({ error: "Never got token" }) })), !0; case 'sign-in-manually': return o.manualEmail ? i().then((e => { chrome.storage.local.set({ userEmail: o.manualEmail }, (function () { })), t({ email: o.manualEmail, untrusted: o.untrusted, userChromeUUID: e }, (function (e, i) { r({ entitlementStatus: e, client_reference_id: n(i) }) })) })) : r({ error: "Didn't pass an email address" }), !0; case 'preview': return chrome.tabs.create({ url: "/playback.html?docId=" + o.docId }), r("ok"), !0; case 'set-author-map': return e.authorMaps[o.docId] = o.authorMap, r("ok"), !0; case 'stats': return chrome.tabs.create({ url: "/stats.html?docId=" + o.docId }), r("ok"), !0; case 'get-stats-data': return e.indexedDB.db ? e.getStatsData(o.docId, (function (n) { r({ sessions: n.sessions, authorMap: e.authorMaps[o.docId], timeline: n.timeline }) })) : e.indexedDB.open().then((() => { e.getStatsData(o.docId, (function (n) { r({ sessions: n.sessions, authorMap: e.authorMaps[o.docId], timeline: n.timeline }) })) })), !0; default: return console.log(o), !0 } })), self.addEventListener('activate', (n => { n.waitUntil(e.indexedDB.open()) })), self.addEventListener('message', (e => { e.data && 'terminate' === e.data.type && self.registration.unregister() })), self.addEventListener('install', (n => { n.waitUntil(e.indexedDB.open()) }));
